

# DSA 2a

## National ID problem

The problem need we to store 60m ID

We have the space to save 100m different numbers

We need to find a mapping function to store 60m ID and not make 2 diff ID save in the same index.

ID form 12-digits national ID

### Suggestion

#### 1st student suggest to save a list of index (mapping function) for NID

- This is bad because it will make the program slower than the direct mapping.

#### Using the last 8 digits

- May lead to complex that last 8 digits of 2 diff NID may the same.

=> Solve this problem the same as previous week, insert if we meet a index that is not empty, go to the neighbor index. 

=> Hashtable, go one by one to the next neighbor, they call  `LINEAR PROBING`




## Practising Linear Probing

### Practice the National ID problem
Student code
```cpp
int hashFunc(int x, int n) {
    return x % n;
}

//x: non-zero valuue, a[i]==0, occupied
//insert x into the HashTable
//return the index of the slot inserted
//collision resolution: Linear Probing
int insert2HashTab(int* a, int n, int x) {
    int pos = hashFunc(x, n);
    while(a[pos] != 0 && a[pos] != x){
        pos = (pos + 1) % n;
    }
    
    if(a[pos] == 0)
            a[pos] = x;
    return pos;
}

//search for x from a Hash Table
//return the index where x is. -1 if not found
int searchHashTab(int* a, int n, int x) {
    int pos = hashFunc(x, n);
    while(a[pos] != 0 && a[pos] != x){
        pos = (pos + 1) % n;
    }
    
    if(a[pos] == x) return pos;
    return -1;
}
```





## Other discussion

##### collide: conflict

#### MD5 
- A string of digit and character
- A special algorithm: [Link](https://vi.wikipedia.org/wiki/MD5)

#### Internet website
- Often people save the password of user by hasing with some secret key to keep user privacy.

#### Problem of Linear Probing

- The Cluster may really big if we make a hash table

## Principle for Hashing.

1. "Good" hash function ("Good": is the hash function that produces hash values that distributed evenly, not "clusterly")
2. Linear Probing may be slow if we search on a cluster because we may have to go pass the data that it not conflict with the data we a manipulate on. So we can sacrifice the memory saving the conflict data at the same block (by sll)

## Practising with Chaining

```cpp
struct Node{
    int data;
    Node* pNext;
};

int hashFunc(int x, int n) {
    return x % n;
}

void insert(Node* &pHead, int x){
    if(!pHead){
        Node* tmp = new Node;
        tmp->data = x;
        tmp->pNext = nullptr;
        pHead = tmp;
        return;
    }
    
    Node* cur = pHead;
    while(cur->pNext){
        cur = cur->pNext;
    }
    
    Node* tmp = new Node;
    tmp->data = x;
    tmp->pNext = nullptr;
    cur->pNext = tmp;
    return;
}

bool finding(Node* pHead, int x){
    
    Node* cur = pHead;
    while(cur && cur->data != x){
        cur = cur->pNext;
    }
    
    if(!cur)
        return false;
    else 
        if(cur->data == x)
            return true;
}

//x: non-zero valuue, a[i]==0, occupied
//insert x into the HashTable
//return the index of the slot inserted
//collision resolution: Linear Probing
int insert2HashTab(Node** a, int n, int x) {
    int pos = hashFunc(x, n);
    insert(a[pos], x);
    return pos;
}

//search for x from a Hash Table
//return the index where x is. -1 if not found
int searchHashTab(Node** a, int n, int x) {
    int pos = hashFunc(x, n);
    if(finding(a[pos], x))
        return pos;
    else
        return -1;
}

int main(){
    int *a;
    a = new int[5];
    
    Node* *a;
    a = new Node*[5];
}
```


## Quadratic probing
- Quite the same with Linear probing:

Linear probing: H, H + 1, H + 2, H + 3,..., 

Quadratic probing: H, H + $1^2$, H + $2^2$, H + $3^2$,...,
